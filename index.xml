<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Thanh&#39;s Notepad </title>
    <link>https://thanhngvpt.github.io/index.xml</link>
    <language>en-us</language>
    <author>thanhngvpt</author>
    <rights>(C) 2016</rights>
    <updated>2016-11-20 17:42:39 &#43;0700 ICT</updated>

    
      
        <item>
          <title>Array, slice, string - mechanic of append</title>
          <link>https://thanhngvpt.github.io/post/go/translate/slice-machanic-of-append/</link>
          <pubDate>Sun, 20 Nov 2016 17:42:39 ICT</pubDate>
          <author>thanhngvpt</author>
          <guid>https://thanhngvpt.github.io/post/go/translate/slice-machanic-of-append/</guid>
          <description>&lt;p&gt;&lt;strong&gt;Introduction&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Một trong những tính năng phổ biến của các ngôn ngữ lập trình thủ tục là khái niệm array. Array có vẻ như là điều đơn giản nhưng có khá nhiều câu hỏi cần được trả lời khi thêm chúng vào một ngôn ngữ như:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- fixed size or variable size?
- is the size part of the type?
- what do multidimensional arrays look like?
- does the empty array have meaning?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Những câu trả lời cho những câu hỏi trên ảnh hưởng tới việc array chỉ là một tính năng của ngôn ngữ hay nó là một phần cốt lõi của thiết kế.&lt;/p&gt;

&lt;p&gt;Trong bản phát triển của go, mất khoảng một năm để trả lời những câu hỏi trên trước khi đưa ra thiết kế chuẩn. Bước đi chính chính là việc giới thiệu slice, slice được built on fixed size array, một cấu trúc dữ liệu linh hoạt và có thể mở rộng. cho tới hôm nay nhiều lập trình viên golang mới thường hiểu sai cách slice hoạt động.&lt;/p&gt;

&lt;p&gt;Bài viết này chúng ta sẽ cố gằng làm sáng tỏ sự mơ hồ này. Chúng ta sẽ cùng xây dựng những đoạn code để giải thích cách built-in function append làm việc.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Array&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Array là một phần khá quan trọng trong go. Giống như nền tảng của một ngôi nhà chúng thường ẩn dưới những thành phần khác. chúng ta phải nói về array trước khi tìm hiểu về slice.&lt;/p&gt;

&lt;p&gt;Array không được sử dụng thường xuyên trong go vì size của array is a part of type, điều này làm hạn chế khả năng diễn đạt của nó. Ta khai báo một biến mảng có tên buffer chứa 256 byte như sau.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var buffer [256]byte
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Một array với [512]byte sẽ khác với type [256]byte type.&lt;/p&gt;

&lt;p&gt;Dữ liệu liên kết với một array là một array of elements nó được mô tả như sau trong bộ nhớ.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;buffer: byte byte byte ... 256 times
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Đó là một biến chứa 256 byte dữ liệu, chúng ta có thể truy cập các phần tử của mảng thông qua index như &lt;code&gt;buffer[0]&lt;/code&gt; &lt;code&gt;buffer[5]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Slice - slice headers&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Slice được sử dụng khá thường xuyên trong go, vì vậy để sử dụng chúng tốt ta cần hiểu nó là gì và nó hoạt động ra sao.&lt;/p&gt;

&lt;p&gt;Một slice là một cấu trúc dữ liệu mô tả một đoạn liên tiếp của một array được lưu trữ riêng biệt với chính slice đó. Slice không phải là một array, slice mô tả một đoạn dữ liệu của một array.&lt;/p&gt;

&lt;p&gt;Ví dụ chúng ta có thể tạo một slice từ array buffer ta đã tạo trước đây từ phần tử thứ 100 đến phần tử thư 149.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var slice []byte = buffer[100:150]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chúng ta cũng có thể viết theo cách idomatic go như nhau&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var slice = buffer[100:150] // or
slice := buffer[100:150]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vậy chính xác thì slice variable là gì? Nó không phải là toàn bộ câu chuyện, bây giờ chúng ta hãy nghĩ slice như một cấu trúc dữ liệu nhỏ với hai phần tử, một là length của slice, một là con trỏ trỏ tới các phần tử của một array, ta có thể hình dung như sau.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type sliceHeader struct {
    Length int
    ZerothElement *byte
}

slice := sliceHeader {
    Length: 50,
    ZerothElement: &amp;amp;buffer[100],
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Trước đây ta mới chỉ slice một array, ta hoàn toàn có thể slice một slice, ví dụ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;slice2 := slice[5:10]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cũng giống như trước đây, lệnh này sẽ tạo ra một slice mới mô tả các phần tử từ vị trí thứ 5 tới vị trí thứ 10 trên underlying array của slice hiện tại (là array &lt;code&gt;buffer&lt;/code&gt;), cụ thể là từ &lt;code&gt;buffer[105]&lt;/code&gt; đến &lt;code&gt;buffer[109]&lt;/code&gt;, &lt;code&gt;slice2&lt;/code&gt; lúc này có dạng.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;slice2 := sliceHeader {
    Length: 5,
    ZerothElement: &amp;amp;buffer[105]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ta cũng có thể reslice lại chính slice đó như việc tạo mới &lt;code&gt;slice2&lt;/code&gt; ở trên.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;slice := slice[5:10]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nếu bạn đã từng nghe những lập trình viên go có kinh nghiệm nói về slice header, thì nó chính là điều chúng ta vừa tìm hiểu ở trên, và thực tế một biến slice chỉ lưu trữ slice header mà thôi. ví dụ khi ta gọi một function nhận vào tham số là một slice thì chính slice header đó được truyền vào function.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Passing slices to functions&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Điều quan trọng là phải hiểu rằng mặc dù một slice chứa một pointer nhưng chính bản thân nó là một giá trị (value). Theo đó nó là một struct value chứa một pointer và một length, không phải là pointer to a struct.&lt;/p&gt;

&lt;p&gt;Phần trước ta có nói về việc truyền slice vào mỗt function, thì một bản copy của slice header của sẽ được truyền vào function, ví dụ.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func AddOneToEachElement(slice []byte) {
    for i := range slice {
        slice[i]++
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mặc dù slice header được truyền bởi value, nhưng slice header chứa một pointer tới các phần tử của một array. Vì vậy cả origin slice header và copy of slice header được truyền vào function đều mô tả trên cùng một array. Tuy nhiên argument thực sự là bản copy ta cùng xem ví dụ.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func SubtractOneFromLength(slice []byte) []byte {
    slice = slice[0:len(slice)-1]
    return slice
}

func main() {
    var slice []byte
    fmt.Println(&amp;quot;Before: len(slice) = &amp;quot;, len(slice)) // 50
    newSlice := SubtractOneFromLength(slice)
    fmt.Println(&amp;quot;After: len(slice) = &amp;quot;, len(slice)) // 50
    fmt.Println(&amp;quot;After: len(newSlice) = &amp;quot;, len(newSlice)) // 49
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Như ta thấy nội dung của slice argument có thể bị chỉnh sửa bởi một function nhưng header của slice đó thì không, length trong slice header không bị chỉnh sửa vì bản copy của slice header được truyền vào chứ không phải origin. bởi vậy nếu ta muốn viết một function chỉnh sửa slice header ta phải trả về kết quả của function đó như ta vừa làm ở trên là newSlice.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pointer to slice - Method receiver&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Một cách khác để viết một function chỉnh sửa slice header là truyền vào function một pointer trỏ tới slice header.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func PtrSubtractOneFromLength(slicePtr *[]byte) {
    slice := *slicePtr
    *slicePtr = slice[0:len(slice)-1]
}

func main() {
    var slice []byte
    fmt.Println(&amp;quot;Before: len(slice) = &amp;quot;, len(slice))
    PtrSubtractOneFromLength(&amp;amp;slice)
    fmt.Println(&amp;quot;After: len(slice) = &amp;quot;, len(slice))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cách trên trông có vẻ không idiomatic go lắm, ta cùng viết lại theo cách idomatic golang như sau.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type path []byte

func (p *path) TruncateAtFinalSlash() {
    i := bytes.LastIndex(*p, []byte(&amp;quot;/&amp;quot;))
    if i &amp;gt;= 0 {
        *p = (*p)[0:i]
    }
}

func main() {
    pathName := path(&amp;quot;/usr/bin/tso&amp;quot;) // conversion from string to path
    pathName.TruncateAtFinalSlash()
    fmt.Printf(&amp;quot;%s\n&amp;quot;, pathName)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mặt khác nếu ta muốn viết một method cho &lt;code&gt;path&lt;/code&gt; làm công việc đổi các kí tự ascii thành kí tự hoa trong &lt;code&gt;path&lt;/code&gt;, thì method nên là value receiver vì value receiver sẽ vẫn trỏ tới cùng underlying array.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Capacity&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Cùng xem xét function mở rộng thêm một phần tử cho slice dưới đây&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Extend(slice []int, element int) []int {
    n := len(slice)
    slice := slice[0:n+1]
    slice[n] = element
    return slice
}

func main() {
    var iBuffer [10]int
    slice := iBuffer[0:0]
    for i := 0; i &amp;lt; 20; i++ {
        slice = Extend(slice, i)
        fmt.Println(slice)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ta chạy code trên đến khi slice đạt 10 phần tử sẽ sinh ra lỗi, lý do vì sao vậy nhỉ? Nguyên nhân là do một thành phần thứ ba trong slice header gọi là capacity. Lúc này slice header có dạng.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type sliceHeader struct {
    Length int
    Capacity int
    ZerothElement *byte
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Capacity&lt;/code&gt; cho ta biết số giới hạn số phần tử mà underlying array có thể lưu trữ. ở trên khi ta gán &lt;code&gt;slice := iBuffer[0:0]&lt;/code&gt; thì slice header sẽ như sau.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;slice := sliceHeader {
    Length: 0,
    Capacity: 10,
    ZerothElement: &amp;amp;iBuffer[0],
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Capacity&lt;/code&gt; nói theo khác chính là length của underlying array&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Make&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Ta lại có vấn đề mới, nếu chúng ta muốn mở rộng slice vượt quá capacity thì làm thế nào, theo định nghĩa, capacity là giới hạn của sự gia tăng phần tử của slice. Tuy nhiên ta có thể đạt được kết quả tương tự bằng việc cấp phát một array mới, rồi copy dữ liệu sang array mới và chỉnh sửa mô tả của slice sang array mới.&lt;/p&gt;

&lt;p&gt;Chúng ta bắt đầu với việc cấp phát. Chúng ta có thể sử dụng builtin function &lt;code&gt;new&lt;/code&gt; để cấp phát một array lớn hơn và tạo một slice header mô tả trên array này. &lt;code&gt;make&lt;/code&gt; function nhận vào ba tham số là: kiểu của slice, length và capacity, ví dụ.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;slice := make([]int, 10, 15)
newSlice := make([]int, len(slice), 2*cap(slice))
for i := range slice {
    newSlice[i] = slice[i]
}
slice = newSlice
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Copy&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Khi chúng ta nhân đôi capacity của slice ở ví dụ trên ta sử dụng vòng lặp để copy dữ liệu từ slice cũ sang slice mới. Go hỗ trợ một builtin function là &lt;code&gt;copy&lt;/code&gt; giúp công việc chuyển đổi dữ liệu rễ ràng hơn, function này nhận vào hai tham số là hai slice rồi copy dữ liệu từ slice bên phải sang slice bên trái, ví dụ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;newSlice := make([]int, len(slice), 2*cap(slice))
copy(newSlice, slice)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;copy&lt;/code&gt; function khá thông minh, nó chỉ copy những cái có thể và chú ý tới length của cả 2 slice, Theo cách khác số lượng phần tử nó copy là tối thiểu của length của 2 slice. Điều này giúp tiết kiệm nhiều thứ, Hơn nữa &lt;code&gt;copy&lt;/code&gt; trả về một integer value, là số phần tử đã được copy.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;copy&lt;/code&gt; cũng có thể được dùng đề dịch chuyển một phần tử như sau.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Insert(slice []int, index, value int) []int {
    // grow slice by one element
    slice := slice[0:len(slice)+1]
    copy(slice[index+1:], slice[index:])
    slice[index] := value
    return slice
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Append&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Trước đây ta đã viết &lt;code&gt;Extend&lt;/code&gt; function để mở rộng slice thêm một phần tử. Function đó có bug, function &lt;code&gt;Insert&lt;/code&gt; cũng vậy, nếu capacity của slice quá nhỏ chương trình của ta sẽ bị crash ngay. Chúng ta cũng fix bug nào.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Extend(slice []int, element int) []int {
    n := len(slice)
    if n == cap(slice) {
        // slice is full, must grow
        // we double its size and add 1, so if the size is zero we still grow
        newSlice := make([]int, len(slice), 2*cap(slice)+1)
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[0:n+1]
    slice[n] = element
    return slice
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Với function &lt;code&gt;Extend&lt;/code&gt; mới ta vừa viết, ta có thể cải thiện để mở rộng slice với nhiều phần tử cùng lúc. Để làm vậy ta sẽ sử dụng khả năng chuyển cái danh sách tham số của hàm thành một slice khi function được gọi, tính năng này gọi là variadic function trong go.&lt;/p&gt;

&lt;p&gt;Ta gọi function mới này là &lt;code&gt;Append&lt;/code&gt;, phiên bản đầu tiên ta có thể gọi function &lt;code&gt;Extend&lt;/code&gt; ở trên nhiều lần bên trong &lt;code&gt;Append&lt;/code&gt;, mã lệnh của Append function trông như sau.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Append(slice []int, items ...int) []int {
    for _, item := range items {
        slice = Extend(slice, item)
    }
    return slice
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chúng ta có thể làm cho &lt;code&gt;Append&lt;/code&gt; hiệu quả ho8n bằng cách chỉ cấp phát một lần.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Append appends the elements to the slice
// Efficient version
func Append(slice []int, elements ...int) []int {
    n := len(slice)
    total := len(slice) + len(elements)
    if total &amp;gt; cap(slice) {
        // Reallocate, grow to 1.5 times the new size, so we can still grow
        newSize := total*3/2 + 1
        newSlice := make([]int, total, newSize)
        copy(newSlice, slice)
    }
    slice = slice[:total]
    copy(slice[n:], elements)
    return slice
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Append - builtin function&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Trên đây chúng ta đã xây dựng Append function khá hiệu quả, tuy nhiên đó chỉ là tiền đề cho việc ra đời của Append builtin làm việc với mọi kiểu của slice.&lt;/p&gt;

&lt;p&gt;Một điểm yếu của go là bất kì generic-type operation phải được cung cấp bởi run-time. Một ngày nào đó nó có thể thay đổi nhưng bây giờ để làm việc với slice dễ dàng hơn, go cung cấp một builtin function &lt;code&gt;append&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Cần nhớ rằng slice header luôn được cập nhật bởi lời gọi append function, bạn cần lưu lại slice được trả về khi gọi append, Trong thực tế trình biên dịch không cho phép bạn gọi append mà không lưu lại kết quả trả về. ví dụ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// create couple of starter slices
slice := []int{1, 2, 3}
slice2 := []int{55, 66, 77}

// Add item to a slice
slice = append(slice, 4) 

// Add slice to slice
slice = append(slice, slice2...)

// make a copy of a slice
slice3 := append([]int(nil), slice...)

// copy a slice to the end of itself
slice = append(slice, slice...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Nil&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Một nil slice có slice header như sau&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sliceHeader {
    Length: 0,
    Capacity: 0,
    ZerothElement: nil,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;hay đơn giản là &lt;code&gt;sliceHeader{}&lt;/code&gt;. Chi tiết chính là element pointer là &lt;code&gt;nil&lt;/code&gt;. Để hiểu nil slice ta cùng xem xét một slice khác được tạo bởi &lt;code&gt;array[0:0]&lt;/code&gt; slice này có leng và cap = 0 nhưng pointer của nó không nil vì thế nó không phải là nil slice. Rõ ràng là một empty slice có thể grow vì nó có underlying array (như trên là &lt;code&gt;array[0:0]&lt;/code&gt;) còn một nil slice thì không thể grow vì nó không có underlying array để lưu giá trị.&lt;/p&gt;

&lt;p&gt;Điều này nói lên rằng một nil slice là có chức năng tương tự một zero-length slice, mặc dù nó không trỏ đến đâu cả. Nó có length và có thể append được với việc cấp phát.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Strings&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;String thực sự rất đơn giản, nó chỉ là một read only byte slice với vài cú pháp mở rộng hỗ trợ bởi ngôn ngữ lập trình.&lt;/p&gt;

&lt;p&gt;Bởi vì chúng là read only, vì thế không cập một capacity (vì ta không thể grow chúng).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// yield the byte valuye &#39;/&#39;
slash := &amp;quot;/usr/ken&amp;quot;[0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chúng ta có thể slice một string thành một sub string như sau.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// yield the string &amp;quot;/usr&amp;quot;
usr := &amp;quot;/usr/ken&amp;quot;[0:4]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chuyển đổi byte slice thành string và ngược lại như sau.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;str := string(usr)
slice := []byte(usr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Underlying array của một string bị ẩn và không thể truy cập nội dung của nó ngoại trừ việc thông qua string, điều đó có nghĩa là khi chúng ta thực hiện những thao tác chuyển đổi (conversion) thì một bản copy của array được tạo ra. Go sẽ lo việc này, ta  không cần bận tâm. Sau khi thực hiện những thao tác chuyển đổi, chỉnh sửa underlying array thì byte slice không ảnh hưởng tới string tương ứng.&lt;/p&gt;

&lt;p&gt;Một hệ quả quan trọng của slice-like design cho string là việc tạo một substring rất hiệu quả. Tất cả những gì cần làm là tạo ra một string header. Vì string là read only, nên original string và result string từ việc thao tác slice có thể chia sẻ cùng một array một cach an toàn.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Conclusion&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Hiểu cách slice hoạt động sẽ giúp cho việc hiểu cách chúng được cài đặt. Có một cấu trúc dữ liệu nhỏ, slice header liên kết với slice variable, và header này mô tả một phẩn của một array riêng biệt đã được cấp phát. Khi chúng ta truyền slice value, bản sao của header được truyền vào nhưng nó vẫn trỏ tới cùng một underlying array&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Haskell Fundamentals</title>
          <link>https://thanhngvpt.github.io/post/haskell/translate/hfm/2_fundamentals/</link>
          <pubDate>Sun, 20 Nov 2016 08:37:59 ICT</pubDate>
          <author>thanhngvpt</author>
          <guid>https://thanhngvpt.github.io/post/haskell/translate/hfm/2_fundamentals/</guid>
          <description>&lt;p&gt;Các function chúng ta định nghĩa cho tới nay bị giới hạn trong ở những thao tác cơ bản như cách gia tăng một số, Trong chương này chúng ta sẽ thảo luận về một số chức năng nâng cao và xem xét về các thao tác trên list.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Program are composed from modules&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Thông thường một chương trình bao gồm nhiều function và định nghĩa kiểu (type definition). Rõ ràng đặt chúng trong một file là 1 ý tưởng tồi tệ. Bởi vậy các ngôn ngữ lập trình hiện đại cung cấp vài công cụ để cấu trúc chương trình bằng cách cho phép nhóm các related definition vào một logic unit được lưu trữ trong 1 file riêng. Trong haskell những unit này gọi là module.&lt;/p&gt;

&lt;p&gt;Ví dụ về định nghĩa một module trong haskell.
&lt;script src=&#34;//gist.github.com/thanhngvpt/75c8695b03afea2a2961a431b2e602cd.js&#34;&gt;&lt;/script&gt;
Module bắt đầu với một header là một comment chứa các thông tin, tác giả, ngày tạo, mô tả ngắn gọn về chức năng của module. Dòng đầu tiên bắt đầu bởi keyword module theo sau là tên của module, dòng tiếp là keyword where và các definition thuộc về module. Lưu ý là tên module trái ngược với tên function và tên biến là phải bắt đầu bằng kí tự hoa. Trong haskell có một module đặc biệt tên là Prelude mà nội dung luôn sẵn có (available). &lt;code&gt;Prelude&lt;/code&gt; chứa tất cả các function được định nghĩa trước trong haskell như &lt;code&gt;+&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; &amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Branches in the control flow&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Cho tới nay các ví dụ của chúng ta đều thực hiện mà không bị ràng buộc bởi điều kiện (conditional), phần nay chúng ta sẽ tìm hiểu về điều kiện trong haskell. Cùng xem xét ví dụ sau về sử dụng conditional trong haskell.
&lt;script src=&#34;//gist.github.com/thanhngvpt/70c93748bd09994625e59ab264485eff.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Binder&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Một binder sẽ bind value tới một name, và sau đó ta có thể truy cập value thông qua name.
&lt;script src=&#34;//gist.github.com/thanhngvpt/7f93e3621a2866445c5b9133fe32e339.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tuple combinding different data items&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Cho tới nay chúng ta mới chỉ biết cách truyền nhiều tham số vào function nhưng chưa biết cách tạo function trả về nhiều value. Chúng ta có thể thực hiện điều này bằng cách sử dụng tuple.
Một tuple sẽ kết hợp nhiều thành phần thành một compound value, tuy nhiên việc kiến tạo một compound value mới chỉ là một nửa câu chuyện, nửa còn lại ta cần decompound, để làm làm vậy haskell hỗ trợ sẵn ta 2 function là fst và snd. Với fst và snd ta không sử dụng một variable để tham chiếu đến toàn bộ compound value thay vào đó ta  phải phân tách cặp thành các thành phần &lt;code&gt;x&lt;/code&gt; &lt;code&gt;y&lt;/code&gt; quá trình này được gọi là decomposition pattern matching&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Method and decorator in Python</title>
          <link>https://thanhngvpt.github.io/post/python/method-and-decorator/</link>
          <pubDate>Sat, 12 Nov 2016 13:03:32 ICT</pubDate>
          <author>thanhngvpt</author>
          <guid>https://thanhngvpt.github.io/post/python/method-and-decorator/</guid>
          <description>&lt;p&gt;&lt;strong&gt;What is decorators?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Một decorator đơn giản là một function nhận vào một function khác làm argument và thay thế function đó bằng một function đã modified.
&lt;script src=&#34;//gist.github.com/thanhngvpt/e87181a5901bf0621a6d7f39cb941bf8.js&#34;&gt;&lt;/script&gt;
Ví dụ này thực chất là decorator chẳng làm gì cả nó chỉ đơn giản là trả về function vừa nhận vào. Cùng xem xét một ví dụ phức tạp hơn.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/thanhngvpt/d10d9df3b4b08327c9cae4584710d3df.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;What is methods?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Một method là một function được bound tới một instance của class, với first parameter được truyền implicit là một instance (self)
&lt;script src=&#34;//gist.github.com/thanhngvpt/1b7c3d84dfd4b0242a9051dcacfb8627.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Static method&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Static method là một plain function được gọi thông qua class hoặc class instance&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Class method&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Class method là một function được bound tới class, với first parameter được truyền implicit là class object đó (cls)&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Object oriented programming in Python</title>
          <link>https://thanhngvpt.github.io/post/python/oop/</link>
          <pubDate>Wed, 09 Nov 2016 03:02:06 ICT</pubDate>
          <author>thanhngvpt</author>
          <guid>https://thanhngvpt.github.io/post/python/oop/</guid>
          <description>&lt;p&gt;&lt;strong&gt;OOP concepts&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;OOP có các concept như sau.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Class: Là prototype/blueprint của một object. Nó gồm một tập các attributes để mô tả cho object, và attributes = data members + methods = (class vars + instance vars) + methods.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Instance: Là một thực thể đơn được tạo từ một class, đã được cấp phát memory. Kiểu như 1 bản copy của class với attributes riêng biệt với từng instance riêng.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Object: Là chỉ một thực thể có attributes. Và hoàn toàn có thể nói một object là một instance của một class.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Class variables: Là các biến được định nghĩa bên trong một class và bên ngoài các method của class đó, &lt;em&gt;nó được chia sẻ cho tất cả các instance của class đó dùng&lt;/em&gt;. Class variables còn được biết đến với tên là static member variables như trong C++, Java, C#. Khi giá trị của class variables thay đổi thì ảnh hưởng tới tất cả các instance của class đó.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Instance variables: Là các biến chỉ có thể sử dụng bởi chính instance đó.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Curl usefuls</title>
          <link>https://thanhngvpt.github.io/post/linux/curl-usefuls/</link>
          <pubDate>Tue, 08 Nov 2016 10:41:31 ICT</pubDate>
          <author>thanhngvpt</author>
          <guid>https://thanhngvpt.github.io/post/linux/curl-usefuls/</guid>
          <description>&lt;p&gt;&lt;strong&gt;What is curl?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Curl là công cụ hỗ trợ transfer data qua một URL, đây là một util khá tiện dụng, được ứng dụng tương đối phổ biến hiện nay ví dụ dùng để test restful api, upload file lên ftp server &amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GET&lt;/strong&gt;&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/thanhngvpt/f4b85fc08dcb40f505d524bcd8e1c92e.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;POST&lt;/strong&gt;&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/thanhngvpt/221e834872b9313886ae82baac662ef8.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Header&lt;/strong&gt;&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/thanhngvpt/e9ae247a5b0289f4eca2c2a2d94ac149.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;OAuth&lt;/strong&gt;&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/thanhngvpt/f157f76789ce1f08535881e9cc537a6b.js&#34;&gt;&lt;/script&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Interface in go</title>
          <link>https://thanhngvpt.github.io/post/go/interface-in-go/</link>
          <pubDate>Wed, 02 Nov 2016 11:28:04 ICT</pubDate>
          <author>thanhngvpt</author>
          <guid>https://thanhngvpt.github.io/post/go/interface-in-go/</guid>
          <description>&lt;p&gt;&lt;strong&gt;What is an interface?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Interface là một tập các methods và cũng là một type&lt;/em&gt;. Nói theo cách của go thì interface là những actions mà type có thể execute thay vì những loại data mà type có thể hold như trong vài ngôn ngữ.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Implement an interface&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Trong go không có từ khóa &lt;code&gt;implement&lt;/code&gt; tường minh như một vài ngôn ngữ, và để implement một interface chỉ cần implement một trong các method có trong interface.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Empty interface&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Empty interface là &lt;code&gt;interface{}&lt;/code&gt;, empty interface không có method nào, vì trong go không có keyword implement nên mọi type đều implement ít nhất là zero method và như vậy là thỏa mãn điều kiện implement của empty interface. Đây chính là nguồn gốc của những phức tạp khi sử dụng interface. Ví dụ với function &lt;code&gt;doSomthing()&lt;/code&gt; dưới đây. &lt;script src=&#34;//gist.github.com/thanhngvpt/1e6dc031374ea543a70c90a9ad0f7f53.js&#34;&gt;&lt;/script&gt;
argument v trong function &lt;code&gt;doSomething()&lt;/code&gt; có type là &lt;code&gt;interface{}&lt;/code&gt; chứ không phải any type như nhiều người lầm tưởng. Phân tích thêm chút phần này nào, flow sẽ là khi truyền 1 vào &lt;code&gt;doSomthing()&lt;/code&gt; một argument go runtime sẽ thực hiện type conversion nếu cần thiết và convert value sang &lt;code&gt;interface{}&lt;/code&gt; value. Mọi value đều chỉ có chính xác 1 type khi runtime và type của &lt;code&gt;v&lt;/code&gt; sẽ là &lt;code&gt;interface{}&lt;/code&gt;. Vậy dữ liệu thực tế được truyền vào &lt;code&gt;doSomthing()&lt;/code&gt; là &lt;code&gt;interface{}&lt;/code&gt; value à? Có gì đó sai sai nhỉ? Lại phân tích tiếp nào.&lt;/p&gt;

&lt;p&gt;Một interface value được kiến tạo vởi 2 phần data như sau:
    - Một con trỏ trỏ tới method table dành cho underlying type của interface value.
    - Một phần trỏ tới data thực sự được lưu trữ bởi interface value.&lt;/p&gt;

&lt;p&gt;Cùng xem xét một ví dụ về interface như sau &lt;script src=&#34;//gist.github.com/thanhngvpt/7ab0a20f868e9ee511cff8c4f17bda5d.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Trong ví dụ trên ta khai báo biến slice &lt;code&gt;vehicles&lt;/code&gt; là &lt;code&gt;Vehicle&lt;/code&gt; value (interface value), mỗi phần tử của &lt;code&gt;vehicles&lt;/code&gt; đều có underlying data khác nhau.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Multiple monitor i3wm</title>
          <link>https://thanhngvpt.github.io/post/linux/multiple-monitor-i3wm/</link>
          <pubDate>Thu, 27 Oct 2016 15:42:47 ICT</pubDate>
          <author>thanhngvpt</author>
          <guid>https://thanhngvpt.github.io/post/linux/multiple-monitor-i3wm/</guid>
          <description>&lt;p&gt;&lt;strong&gt;What is i3?&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;i3 is a tiling window manager, completely written from scratch. The target platforms are GNU/Linux and BSD operating systems, our code is Free and Open Source Software (FOSS) under the BSD license. i3 is primarily targeted at advanced users and developers. Based upon the experiences we made when wanting to hack/fix wmii, we agreed upon the following goals for i3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Working with multiple monitor&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Kiểm tra xem monitor đã được kết nối vào hệ thống chưa. Mở terminal và chạy lệnh.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;xrandr&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;được thông tin dạng như sau&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Screen 0: minimum 8 x 8, current 2732 x 768, maximum 32767 x 32767
LVDS1 connected 1366x768+1366+0 (normal left inverted right x axis y axis) 310mm x 170mm
   1366x768      60.10*+
   1024x768      60.00  
   1024x576      60.00  
   960x540       60.00  
   800x600       60.32    56.25  
   864x486       60.00  
   640x480       59.94  
   720x405       60.00  
   680x384       60.00  
   640x360       60.00  
DP1 disconnected (normal left inverted right x axis y axis)
HDMI1 disconnected (normal left inverted right x axis y axis)
VGA1 connected 1366x768+0+0 (normal left inverted right x axis y axis) 410mm x 230mm
   1366x768      59.79*+
   1280x1024     60.02  
   1280x720      60.00  
   1024x768      60.00  
   800x600       60.32  
   640x480       59.94  
   720x400       70.08  
VIRTUAL1 disconnected (normal left inverted right x axis y axis)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Chạy tiếp lệnh.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xrandr --ouput VGA1 --auto --left-of LVDS1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Trong đó:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;VGA1, LVDS, HDMI1 là tên của các monitor device đã connect vào trong hệ thông.&lt;/li&gt;
&lt;li&gt;Các tham số: &amp;ndash;output, &amp;ndash;auto, &amp;ndash;left-of quyết định hiển thị của monitor (xem help để biết thêm).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Xem thêm tại &lt;a href=&#34;https://i3wm.org/docs/userguide.html#multi_monitor&#34;&gt;mulitple monitor in i3wm&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Django practices</title>
          <link>https://thanhngvpt.github.io/post/python/django/django-practices/</link>
          <pubDate>Wed, 26 Oct 2016 11:20:47 ICT</pubDate>
          <author>thanhngvpt</author>
          <guid>https://thanhngvpt.github.io/post/python/django/django-practices/</guid>
          <description>&lt;p&gt;&lt;strong&gt;What is django?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Lời mô tả súc tích từ &lt;a href=&#34;https://djangoproject.com&#34;&gt;https://djangoproject.com&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;The web framework for perfectionists with deadlines&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Django là một MVT framework&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Manage dependencies&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip freeze &amp;gt; requirements.txt
pip install -r requirements.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Project layout&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Đặt tên app ngắn gọn, súc tích nhất có thể, nên cố gắng đặt tên bằng 1 chữ.&lt;/li&gt;
&lt;li&gt;Sử dụng kiến trúc nhiều app nhỏ thay vì một app lớn.&lt;/li&gt;
&lt;li&gt;Sử dụng triệt để các app built-in và 3rd-party app.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Settings&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Sử dụng nhiều file settings cho mỗi env: production, dev, staging, testing.&lt;/li&gt;
&lt;li&gt;Sử dụng file settings cho mỗi user.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tất cả các file settings đều kế thừa từ base.&lt;/p&gt;

&lt;p&gt;INSTALLED_APP += (&amp;lsquo;debug_toolbar&amp;rsquo;, )&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Fat models, thin views&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Cố gắng giữ cho views đơn giản nhất có thể.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Deployment&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Webserver: nginx + gunicorn + supervisord + docker.&lt;/li&gt;
&lt;li&gt;Static server: nginx, or amazone S3, CDN.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Asynchronous&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Sử dụng celery để thực thi các task async.&lt;/li&gt;
&lt;li&gt;Sử dụng redis làm message queue cho celery.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Monitor error&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Sử dụng triệt để python logger.&lt;/li&gt;
&lt;li&gt;Sử dụng sentry.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Debugging&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Debug sử dụng trực tiếp của pycharm.&lt;/li&gt;
&lt;li&gt;Sử dụng thêm django-debug-toolbar.&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Vim usefuls</title>
          <link>https://thanhngvpt.github.io/post/tools/vim-usefuls/</link>
          <pubDate>Sun, 23 Oct 2016 00:13:54 ICT</pubDate>
          <author>thanhngvpt</author>
          <guid>https://thanhngvpt.github.io/post/tools/vim-usefuls/</guid>
          <description>&lt;p&gt;Vim là 1 trình soạn thảo văn bản nhỏ gọn nhưng cực kì khỏe, nếu được cài đầy đủ plugin nó hoàn toàn có thể sánh ngang các IDE hầm hố. Vim được khá nhiều dev lão luyện dùng điều này cho thấy nó khá tốt và cần đưa vào diện tình nghi ngay nếu chưa biết gì về nó.&lt;/p&gt;

&lt;p&gt;Vim mạnh mẽ nhờ hệ thống plugin khổng lồ đáp ứng hầu hết các yêu cầu của các dev, để cài đặt plugin cho vim ta có thể sử dụng nhiều cách, tuy nhiên cách được sử dụng phổ biến và được khuyến khích là sử dụng một plugin manager, plugin manager lại có vài cái tên để lựa chọn như vundle, neobundle, pathogen &amp;hellip; trong số này thì vundle là cái được khuyến khích. Để cài một plugin sử dụng vundle có thể thêm plugin đó vào file .vimrc hoặc khởi động vim và chạy lệnh :PluginInstall name. Dưới đây là danh sách các plugin nên có.&lt;/p&gt;

&lt;p&gt;Các plugin hay nên cài trong vim: nerdtree, auto-pairs, neocomplete, syntastic, ack, gitv, fugitive.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Các câu lệnh và thao tác hữu ích trong vim&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;windows&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;Chia cửa sổ hiện tại thành 2 cửa sổ nằm ngang ctrl + w, ctrl + S (shift + s).&lt;/li&gt;
&lt;li&gt;Chia cửa sổ hiện tại thành 2 cửa sổ nằm dọc ctrl + w, ctrl + v&lt;/li&gt;
&lt;li&gt;Di chuyển qua lại giữa các cửa số nhấn ctrl+w 2 lần hoặc ấn ctrl+w rồi sử dụng phím di duyển (gồm: hjkl hoặc các phím mũi tên).&lt;/li&gt;
&lt;li&gt;Thay đổi kích thước cửa sổ:

&lt;ul&gt;
&lt;li&gt;Horizontal (ngang) gõ lệnh :&lt;number_of_column&gt;winc +/- (tăng/giảm).&lt;/li&gt;
&lt;li&gt;Vertical (dọc) gõ lệnh :&lt;number_of_comlumn&gt;winc &amp;gt;/&amp;lt; (tăng/giảm).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Simple Python server</title>
          <link>https://thanhngvpt.github.io/post/python/simple-python-server/</link>
          <pubDate>Sat, 22 Oct 2016 09:07:38 ICT</pubDate>
          <author>thanhngvpt</author>
          <guid>https://thanhngvpt.github.io/post/python/simple-python-server/</guid>
          <description>&lt;p&gt;Server là từ ngữ khá thần thánh và phổ biến trong giới IT, định nghĩa về server theo wikipedia như sau.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;a server is a computer program or a device that provides functionality for other programs or devices&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Hiểu biết sâu về server sẽ rất có ích cho các ITer. Bài viết này sẽ xem xét về ứng dụng http server built-in của python để chia sẻ file trong mạng LAN.&lt;/p&gt;

&lt;p&gt;cd tới thư mục muốn chia sẻ rồi chạy lệnh&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# python 3
python -m http.server
#
# python 2
python2 -m SimpleHTTPServer
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Mode algorithm</title>
          <link>https://thanhngvpt.github.io/post/go/mode-algorithm/</link>
          <pubDate>Fri, 21 Oct 2016 14:15:20 ICT</pubDate>
          <author>thanhngvpt</author>
          <guid>https://thanhngvpt.github.io/post/go/mode-algorithm/</guid>
          <description>&lt;p&gt;Mode algorithm là thuật toán được sử dụng để tìm ra phần tử lặp lại nhiều nhất trong một array. Source dưới đây cài đặt cho thuật toán tìm mode của 1 array sử dụng ngôn ngữ Go.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// sử dụng slice
function sliceMode(input []int) int {
    count := make([]input, len(input))
    maxValue := 0
    maxKey := 0
    for i := range input {
        count[input[i]]++
        if count[input[i]] &amp;gt; maxValue {
            maxValue = count[input[i]]
            maxKey = input[i]
        }
    }

    return maxKey
}

// sử dụng map
function mapMode([]input) int {
    count := make(map[int]int)
    maxValue, maxKey := 0, 0
    for i := range input {
        count[input[i]]++
        if count[input[i]] &amp;gt; maxValue {
            maxValue = count[input[i]]
            maxKey = input[i]
        }
    }

    return maxKey
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>createClass vs Component in React</title>
          <link>https://thanhngvpt.github.io/post/react/create-class-vs-component/</link>
          <pubDate>Thu, 20 Oct 2016 15:55:47 ICT</pubDate>
          <author>thanhngvpt</author>
          <guid>https://thanhngvpt.github.io/post/react/create-class-vs-component/</guid>
          <description>&lt;p&gt;Để tạo một react component ta có thể dùng cú pháp&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// cách 1
const = react.createClass({
    getInitialState() {
        return {name: &#39;David&#39;}
    },

    propTypes: {},

    getDefaultProps() {
        return {}
    },

    handleClick() {
        console.log(this);
    },

    render() {
        return (
            &amp;lt;div&amp;gt;
                &amp;lt;h1&amp;gt;Hello, {this.state.name}&amp;lt;/h1&amp;gt;
            &amp;lt;/div&amp;gt;
        );
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;hoặc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// cách 2
class Comment extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            name: &#39;David&#39;
        };
        this.handleClick = this.handleClick.bind(this);
    }

    handleClick() {
        console.log(this);
    }

    render() {
        return (
            &amp;lt;div&amp;gt;
                &amp;lt;h1&amp;gt;Hello, {this.state.name}&amp;lt;/h1&amp;gt;
            &amp;lt;/div&amp;gt;
        );
    }
}

Comment.propTypes = {};
Comment.defaultProps = {};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Về bản chất hai cú pháp đều thực hiện công việc giống nhau, cách 1 sử dụng cú pháp ES5 cách 2 sử dụng cú pháp ES6. Vài điểm khác nhau giữa 2 cách như sau:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;initState: cách 1 dùng function getInitialState(), cách 2 set object trong constructor.&lt;/li&gt;
&lt;li&gt;defaultProps: cách 1 là sử dụng function getDefaultProps(), cách 2 set object defaultProps.&lt;/li&gt;
&lt;li&gt;handler Event: cách 1 tự động bind vào component khi gọi, cách 2 phải bind manual hoặc bind trong constructor.&lt;/li&gt;
&lt;li&gt;mixin: cách 1 hỗ trợ, cách 2 không hỗ trợ&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Python tricks</title>
          <link>https://thanhngvpt.github.io/post/python/python-tricks/</link>
          <pubDate>Thu, 20 Oct 2016 14:57:11 ICT</pubDate>
          <author>thanhngvpt</author>
          <guid>https://thanhngvpt.github.io/post/python/python-tricks/</guid>
          <description>&lt;p&gt;&lt;strong&gt;Unpacking&lt;/strong&gt;&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/thanhngvpt/4c11f8cb2d77547dc7d1344ffc720e2e.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Negative indexing&lt;/strong&gt;&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/thanhngvpt/e7af21b776415714e46104c0d35e70e5.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Slicing&lt;/strong&gt;&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/thanhngvpt/736739edb57a3deba50209e19706d96a.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Iterating&lt;/strong&gt;&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/thanhngvpt/cf245eb17d152bd7dc0677902db2cfbe.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Zipping and unzipping&lt;/strong&gt;&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/thanhngvpt/2ba6195c0cb95aad3ea58f9add05c66c.js&#34;&gt;&lt;/script&gt;
</description>
        </item>
      
    

  </channel>
</rss>
